import { tool } from "@opencode-ai/plugin";

export default tool({
  description: `Search the codebase using semantic RAG (Retrieval-Augmented Generation). Uses raggrep to find relevant code snippets based on natural language queries. The index is managed automatically - first query creates it, changed files are re-indexed, and unchanged files use cached index.

IMPORTANT: When you have context about where relevant code is likely to be located (or where it definitely ISN'T), always use the 'filter' parameter to narrow results. This improves search quality and performance significantly.

Examples of good filter usage:
- Searching for auth logic? Use filter: ["src/auth", "src/users"]
- Looking for React components? Use filter: ["*.tsx", "src/components"]
- Need documentation? Use filter: ["*.md", "docs/"]
- Looking for tests? Use filter: ["*.test.ts", "*.spec.ts"]
- Focused on source code? Use filter: ["src/"]`,
  args: {
    query: tool.schema
      .string()
      .describe(
        "Natural language search query (e.g., 'user authentication', 'handle errors')"
      ),
    top: tool.schema
      .number()
      .optional()
      .describe("Number of results to return (default: 10)"),
    minScore: tool.schema
      .number()
      .optional()
      .describe("Minimum similarity score 0-1 (default: 0.15)"),
    type: tool.schema
      .string()
      .optional()
      .describe(
        "Filter by file extension without dot (e.g., 'ts', 'tsx', 'js', 'md'). Use this for simple extension filtering."
      ),
    filter: tool.schema
      .array(tool.schema.string())
      .optional()
      .describe(
        "RECOMMENDED: Filter by path prefix or glob pattern to narrow search scope. Multiple filters use OR logic. Always include a filter when you know (or can reasonably guess) where the code lives. Examples: 'src/auth' (path prefix), '*.ts' (extension glob), 'src/**/*.test.ts' (nested glob), 'docs/' (directory)"
      ),
  },
  async execute(args) {
    const cmdArgs = [args.query];

    if (args.top !== undefined) {
      cmdArgs.push("--top", String(args.top));
    }
    if (args.minScore !== undefined) {
      cmdArgs.push("--min-score", String(args.minScore));
    }
    if (args.type !== undefined) {
      cmdArgs.push("--type", args.type);
    }
    if (args.filter !== undefined && args.filter.length > 0) {
      for (const f of args.filter) {
        cmdArgs.push("--filter", f);
      }
    }

    const result = await Bun.$`raggrep query ${cmdArgs}`.text();
    return result.trim();
  },
});
